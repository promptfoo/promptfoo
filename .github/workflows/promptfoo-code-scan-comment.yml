name: Post Code Scan Comments

# This workflow runs after the Promptfoo Code Scan completes
# It posts PR comments using elevated permissions (works for fork PRs)
on:
  workflow_run:
    workflows: ['Promptfoo Code Scan']
    types: [completed]

jobs:
  post-comments:
    runs-on: ubuntu-latest
    # Only run if the scan workflow succeeded and was triggered by a PR
    if: >
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'pull_request'
    permissions:
      pull-requests: write
      actions: read

    steps:
      - name: Download scan results
        id: download
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: code-scan-results
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Post comments to PR
        if: steps.download.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read scan results
            let scanData;
            try {
              const content = fs.readFileSync('scan-results.json', 'utf8');
              scanData = JSON.parse(content);
            } catch (error) {
              core.info('No scan results found or failed to parse');
              return;
            }

            const { scanResponse, prContext, minimumSeverity } = scanData;
            const { comments, review } = scanResponse;

            if (!comments || comments.length === 0) {
              core.info('No findings to post');
              return;
            }

            core.info(`Posting ${comments.length} findings to PR #${prContext.number}`);

            // Format severity with emoji
            const formatSeverity = (severity) => {
              const severityMap = {
                'critical': 'üî¥ **Critical**',
                'high': 'üü† **High**',
                'medium': 'üü° **Medium**',
                'low': 'üîµ **Low**'
              };
              return severityMap[severity?.toLowerCase()] || '';
            };

            // Separate line-specific comments from general comments
            const lineComments = comments.filter(c => c.file && c.line);
            const generalComments = comments.filter(c => !c.file || !c.line);

            // Post review with line-specific comments
            if (lineComments.length > 0 || review) {
              try {
                const reviewComments = lineComments.map(c => {
                  let body = '';
                  if (c.severity) {
                    body += formatSeverity(c.severity) + ' ';
                  }
                  body += c.finding;

                  if (c.fix) {
                    body += `\n\n<details>\n<summary>üí° Suggested Fix</summary>\n\n${c.fix}\n</details>`;
                  }
                  if (c.aiAgentPrompt) {
                    body += `\n\n<details>\n<summary>ü§ñ AI Agent Prompt</summary>\n\n${c.aiAgentPrompt}\n</details>`;
                  }

                  return {
                    path: c.file,
                    line: c.line,
                    start_line: c.startLine && c.startLine < c.line ? c.startLine : undefined,
                    side: 'RIGHT',
                    start_side: c.startLine && c.startLine < c.line ? 'RIGHT' : undefined,
                    body
                  };
                });

                await github.rest.pulls.createReview({
                  owner: prContext.owner,
                  repo: prContext.repo,
                  pull_number: prContext.number,
                  event: 'COMMENT',
                  body: review || undefined,
                  comments: reviewComments.length > 0 ? reviewComments : undefined
                });

                core.info(`Posted review with ${reviewComments.length} inline comments`);
              } catch (error) {
                core.warning(`Failed to post inline comments: ${error.message}`);
                core.info('Falling back to summary comment...');

                // Fallback: post as summary comment
                const summaryBody = lineComments.map(c => {
                  const lineRange = c.startLine && c.startLine !== c.line
                    ? `${c.file}:${c.startLine}-${c.line}`
                    : `${c.file}:${c.line}`;

                  let text = `**${lineRange}**\n\n`;
                  if (c.severity) {
                    text += formatSeverity(c.severity) + ' ';
                  }
                  text += c.finding;

                  if (c.fix) {
                    text += `\n\n<details>\n<summary>üí° Suggested Fix</summary>\n\n${c.fix}\n</details>`;
                  }
                  return text;
                }).join('\n\n---\n\n');

                await github.rest.issues.createComment({
                  owner: prContext.owner,
                  repo: prContext.repo,
                  issue_number: prContext.number,
                  body: `## üîç LLM Security Scan Results\n\n${summaryBody}`
                });

                core.info('Posted summary comment');
              }
            }

            // Post general comments
            for (const comment of generalComments) {
              try {
                let body = '';
                if (comment.severity) {
                  body += formatSeverity(comment.severity) + ' ';
                }
                body += comment.finding;

                if (comment.fix) {
                  body += `\n\n<details>\n<summary>üí° Suggested Fix</summary>\n\n${comment.fix}\n</details>`;
                }
                if (comment.aiAgentPrompt) {
                  body += `\n\n<details>\n<summary>ü§ñ AI Agent Prompt</summary>\n\n${comment.aiAgentPrompt}\n</details>`;
                }

                await github.rest.issues.createComment({
                  owner: prContext.owner,
                  repo: prContext.repo,
                  issue_number: prContext.number,
                  body
                });
              } catch (error) {
                core.warning(`Failed to post general comment: ${error.message}`);
              }
            }

            core.info('All comments posted successfully');
