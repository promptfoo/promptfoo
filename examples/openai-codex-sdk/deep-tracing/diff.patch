diff --git a/src/providers/openai/codex-sdk.ts b/src/providers/openai/codex-sdk.ts
index 4125ea419..82bfa472a 100644
--- a/src/providers/openai/codex-sdk.ts
+++ b/src/providers/openai/codex-sdk.ts
@@ -7,6 +7,14 @@ import cliState from '../../cliState';
 import { getEnvString } from '../../envars';
 import { importModule, resolvePackageEntryPoint } from '../../esm';
 import logger from '../../logger';
+import { trace, SpanKind, SpanStatusCode } from '@opentelemetry/api';
+import {
+  withGenAISpan,
+  getTraceparent,
+  sanitizeBody,
+  type GenAISpanContext,
+  type GenAISpanResult,
+} from '../../tracing/genaiTracer';
 
 import type {
   ApiProvider,
@@ -143,6 +151,20 @@ export interface OpenAICodexSDKConfig {
    * Enable streaming events (default: false for simplicity)
    */
   enable_streaming?: boolean;
+
+  /**
+   * Enable deep tracing of Codex CLI operations.
+   * When enabled, injects OTEL environment variables so the Codex CLI
+   * exports its internal spans to the local OTLP receiver.
+   * Requires tracing.enabled and tracing.otlp.http.enabled in promptfooconfig.
+   *
+   * IMPORTANT: Deep tracing is INCOMPATIBLE with thread persistence.
+   * When enabled, persist_threads, thread_id, and thread_pool_size are ignored
+   * because the CLI process must be recreated for each call to get correct span linking.
+   *
+   * Default: false (only traces at provider level, not CLI internals)
+   */
+  deep_tracing?: boolean;
 }
 
 /**
@@ -245,7 +267,9 @@ export class OpenAICodexSDKProvider implements ApiProvider {
   private providerId = 'openai:codex-sdk';
   private codexModule?: any;
   private codexInstance?: any;
+  private codexInstanceEnvHash?: string; // Track env hash to detect changes
   private threads: Map<string, any> = new Map();
+  private deepTracingWarningShown = false; // Show warning once per instance
 
   constructor(
     options: {
@@ -284,10 +308,31 @@ export class OpenAICodexSDKProvider implements ApiProvider {
   }
 
   async cleanup(): Promise<void> {
+    // Clean up threads
     this.threads.clear();
+
+    // Clean up Codex instance to release resources (child processes, file handles)
+    if (this.codexInstance) {
+      try {
+        if (typeof this.codexInstance.destroy === 'function') {
+          await this.codexInstance.destroy();
+        } else if (typeof this.codexInstance.cleanup === 'function') {
+          await this.codexInstance.cleanup();
+        } else if (typeof this.codexInstance.close === 'function') {
+          await this.codexInstance.close();
+        }
+      } catch (error) {
+        logger.warn('[CodexSDK] Error during cleanup', { error });
+      }
+      this.codexInstance = undefined;
+      this.codexInstanceEnvHash = undefined;
+    }
   }
 
-  private prepareEnvironment(config: OpenAICodexSDKConfig): Record<string, string> {
+  private prepareEnvironment(
+    config: OpenAICodexSDKConfig,
+    traceparent?: string,
+  ): Record<string, string> {
     const env: Record<string, string> = config.cli_env
       ? { ...config.cli_env }
       : ({ ...process.env } as Record<string, string>);
@@ -316,6 +361,38 @@ export class OpenAICodexSDKProvider implements ApiProvider {
       }
     }
 
+    // Inject OpenTelemetry configuration for deep tracing
+    // This allows the Codex CLI to export its internal traces to our OTLP receiver
+    // Only enabled when config.deep_tracing is true AND we have a trace context
+    // Without deep_tracing, we still capture spans at the provider level but don't
+    // inject OTEL vars into CLI (which would cause export errors if no collector)
+    if (traceparent && config.deep_tracing) {
+      // Standard OTEL environment variables - use defaults only if not already set
+      if (!sortedEnv.OTEL_EXPORTER_OTLP_ENDPOINT) {
+        sortedEnv.OTEL_EXPORTER_OTLP_ENDPOINT = 'http://127.0.0.1:4318';
+      }
+      if (!sortedEnv.OTEL_EXPORTER_OTLP_PROTOCOL) {
+        sortedEnv.OTEL_EXPORTER_OTLP_PROTOCOL = 'http/json';
+      }
+      if (!sortedEnv.OTEL_SERVICE_NAME) {
+        sortedEnv.OTEL_SERVICE_NAME = 'codex-cli';
+      }
+      if (!sortedEnv.OTEL_TRACES_EXPORTER) {
+        sortedEnv.OTEL_TRACES_EXPORTER = 'otlp';
+      }
+      // W3C Trace Context - always set to current trace for proper parent-child linking
+      sortedEnv.TRACEPARENT = traceparent;
+      logger.debug('[CodexSDK] Injecting OTEL config for deep tracing', {
+        traceparent,
+        endpoint: sortedEnv.OTEL_EXPORTER_OTLP_ENDPOINT,
+        userConfigured: {
+          endpoint: !!env.OTEL_EXPORTER_OTLP_ENDPOINT,
+          protocol: !!env.OTEL_EXPORTER_OTLP_PROTOCOL,
+          serviceName: !!env.OTEL_SERVICE_NAME,
+        },
+      });
+    }
+
     return sortedEnv;
   }
 
@@ -422,23 +499,151 @@ export class OpenAICodexSDKProvider implements ApiProvider {
     const { events } = await thread.runStreamed(prompt, runOptions);
     const items: any[] = [];
     let usage: any = undefined;
+    const tracer = trace.getTracer('promptfoo.codex-sdk');
 
-    for await (const event of events) {
-      // Check abort signal
-      if (callOptions?.abortSignal?.aborted) {
-        throw new Error('AbortError');
-      }
+    // Track in-progress spans for items (keyed by item.id)
+    const activeSpans: Map<string, ReturnType<typeof tracer.startSpan>> = new Map();
+    // Track start times for items (used for items that only have item.completed)
+    const itemStartTimes: Map<string, number> = new Map();
+    // Track the last event timestamp to estimate start times for items without item.started
+    let lastEventTime = Date.now();
 
-      switch (event.type) {
-        case 'item.completed':
-          items.push(event.item);
-          logger.debug('Codex item completed', { item: event.item });
-          break;
-        case 'turn.completed':
-          usage = event.usage;
-          logger.debug('Codex turn completed', { usage });
-          break;
+    // Collect reasoning for parent span event
+    const reasoningTexts: string[] = [];
+    // Track all prompts/messages in the conversation
+    const conversationMessages: Array<{ role: string; content: string }> = [];
+
+    // Add the initial user prompt
+    conversationMessages.push({ role: 'user', content: prompt });
+
+    try {
+      for await (const event of events) {
+        const eventTime = Date.now();
+
+        // Check abort signal
+        if (callOptions?.abortSignal?.aborted) {
+          throw new Error('AbortError');
+        }
+
+        switch (event.type) {
+          case 'item.started': {
+            // Create a child span for this item
+            const item = event.item;
+            const spanName = this.getSpanNameForItem(item);
+            const span = tracer.startSpan(spanName, {
+              kind: SpanKind.INTERNAL,
+              attributes: {
+                'codex.item.id': item.id,
+                'codex.item.type': item.type,
+                ...this.getAttributesForItem(item),
+              },
+            });
+            activeSpans.set(item.id, span);
+            itemStartTimes.set(item.id, eventTime);
+            logger.debug('Codex item started', { itemId: item.id, type: item.type });
+            break;
+          }
+          case 'item.completed': {
+            const item = event.item;
+            items.push(item);
+
+            // Collect reasoning text for summary
+            if (item.type === 'reasoning' && item.text) {
+              reasoningTexts.push(item.text);
+            }
+
+            // Collect agent messages for conversation history
+            if (item.type === 'agent_message' && item.text) {
+              conversationMessages.push({ role: 'assistant', content: item.text });
+            }
+
+            // Get or create span for this item
+            // Some item types (like reasoning) may only emit item.completed without item.started
+            let span = activeSpans.get(item.id);
+            const hadStartEvent = span !== undefined;
+
+            if (!span) {
+              // Create span retroactively for items without item.started event
+              // Use lastEventTime as approximate start time
+              const spanName = this.getSpanNameForItem(item);
+              span = tracer.startSpan(spanName, {
+                kind: SpanKind.INTERNAL,
+                startTime: lastEventTime,
+                attributes: {
+                  'codex.item.id': item.id,
+                  'codex.item.type': item.type,
+                  'codex.timing.estimated': true, // Mark that timing is estimated
+                  ...this.getAttributesForItem(item),
+                },
+              });
+            }
+
+            // Add completion attributes
+            const completionAttrs = this.getCompletionAttributesForItem(item);
+            for (const [key, value] of Object.entries(completionAttrs)) {
+              span.setAttribute(key, value);
+            }
+
+            // Calculate and record duration
+            const startTime = itemStartTimes.get(item.id) || lastEventTime;
+            const durationMs = eventTime - startTime;
+            span.setAttribute('codex.duration_ms', durationMs);
+            span.setAttribute('codex.had_start_event', hadStartEvent);
+
+            // Add span events for rich content types (sanitized to prevent secret leakage)
+            if (item.type === 'reasoning' && item.text) {
+              span.addEvent('reasoning', {
+                'codex.reasoning.text': this.sanitizeText(item.text, 4096),
+                'codex.reasoning.full_length': item.text.length,
+              });
+            }
+            if (item.type === 'agent_message' && item.text) {
+              span.addEvent('message', {
+                'codex.message.text': this.sanitizeText(item.text, 4096),
+                'codex.message.full_length': item.text.length,
+              });
+            }
+            if (item.type === 'command_execution' && item.aggregated_output) {
+              span.addEvent('output', {
+                'codex.command.output': this.sanitizeText(item.aggregated_output, 4096),
+                'codex.command.output_length': item.aggregated_output.length,
+              });
+            }
+
+            // Set status based on item
+            if (item.status === 'failed' || item.type === 'error') {
+              span.setStatus({
+                code: SpanStatusCode.ERROR,
+                message: item.message || item.error?.message || 'Item failed',
+              });
+            } else {
+              span.setStatus({ code: SpanStatusCode.OK });
+            }
+
+            span.end();
+            activeSpans.delete(item.id);
+            itemStartTimes.delete(item.id);
+            logger.debug('Codex item completed', { itemId: item.id, type: item.type, durationMs });
+            break;
+          }
+          case 'turn.completed':
+            usage = event.usage;
+            logger.debug('Codex turn completed', { usage });
+            break;
+        }
+
+        // Update last event time for next iteration
+        lastEventTime = eventTime;
+      }
+    } finally {
+      // End any remaining spans (handles abort/error cases)
+      for (const [itemId, span] of activeSpans) {
+        logger.warn('Codex item span not properly closed', { itemId });
+        span.setStatus({ code: SpanStatusCode.ERROR, message: 'Span not properly closed' });
+        span.end();
       }
+      activeSpans.clear();
+      itemStartTimes.clear();
     }
 
     // Extract text from agent_message items for final response
@@ -450,9 +655,141 @@ export class OpenAICodexSDKProvider implements ApiProvider {
       finalResponse,
       items,
       usage,
+      // Include collected data for parent span enrichment
+      reasoningTexts,
+      conversationMessages,
     };
   }
 
+  /**
+   * Get a descriptive span name for a Codex item
+   */
+  private getSpanNameForItem(item: any): string {
+    switch (item.type) {
+      case 'command_execution':
+        return `exec ${item.command?.split(' ')[0] || 'command'}`;
+      case 'file_change':
+        return `file ${item.changes?.[0]?.kind || 'change'}`;
+      case 'mcp_tool_call':
+        return `mcp ${item.server}/${item.tool}`;
+      case 'agent_message':
+        return 'agent response';
+      case 'reasoning':
+        return 'reasoning';
+      case 'web_search':
+        return `search "${item.query?.slice(0, 30) || ''}"`;
+      case 'todo_list':
+        return 'todo update';
+      case 'error':
+        return 'error';
+      default:
+        return `codex.${item.type || 'unknown'}`;
+    }
+  }
+
+  /**
+   * Sanitize and truncate text content for span attributes.
+   * Prevents secret leakage and controls attribute size.
+   */
+  private sanitizeText(text: string, maxLength: number = 1000): string {
+    const sanitized = sanitizeBody(text);
+    if (sanitized.length <= maxLength) {
+      return sanitized;
+    }
+    return sanitized.slice(0, maxLength - 15) + '... [truncated]';
+  }
+
+  /**
+   * Sanitize a file path to remove PII (usernames from home directories).
+   * Converts absolute paths like /Users/john.doe/projects/foo/bar.ts to ~/projects/foo/bar.ts
+   */
+  private sanitizePath(filePath: string): string {
+    // Patterns for home directories on various systems
+    // macOS: /Users/username/
+    // Linux: /home/username/
+    // Windows: C:\Users\username\
+    const homePatterns = [
+      /^\/Users\/[^/]+\//,
+      /^\/home\/[^/]+\//,
+      /^[A-Z]:\\Users\\[^\\]+\\/i,
+    ];
+
+    let sanitized = filePath;
+    for (const pattern of homePatterns) {
+      sanitized = sanitized.replace(pattern, '~/');
+    }
+    return sanitized;
+  }
+
+  /**
+   * Get attributes for a Codex item at start
+   */
+  private getAttributesForItem(item: any): Record<string, string | number | boolean> {
+    const attrs: Record<string, string | number | boolean> = {};
+
+    switch (item.type) {
+      case 'command_execution':
+        // Sanitize commands as they may contain credentials (API keys in curl, env vars, etc.)
+        if (item.command) attrs['codex.command'] = this.sanitizeText(item.command, 2000);
+        break;
+      case 'mcp_tool_call':
+        // Server and tool names are safe identifiers, no sanitization needed
+        if (item.server) attrs['codex.mcp.server'] = item.server;
+        if (item.tool) attrs['codex.mcp.tool'] = item.tool;
+        break;
+      case 'web_search':
+        // Sanitize search queries as they may contain sensitive information
+        if (item.query) attrs['codex.search.query'] = this.sanitizeText(item.query, 500);
+        break;
+    }
+
+    return attrs;
+  }
+
+  /**
+   * Get attributes for a Codex item at completion
+   */
+  private getCompletionAttributesForItem(item: any): Record<string, string | number | boolean> {
+    const attrs: Record<string, string | number | boolean> = {};
+
+    switch (item.type) {
+      case 'command_execution':
+        if (item.exit_code !== undefined) attrs['codex.exit_code'] = item.exit_code;
+        if (item.status) attrs['codex.status'] = item.status;
+        // Sanitize and truncate output to prevent secret leakage
+        if (item.aggregated_output) {
+          attrs['codex.output'] = this.sanitizeText(item.aggregated_output, 1000);
+        }
+        break;
+      case 'file_change':
+        if (item.status) attrs['codex.status'] = item.status;
+        if (item.changes?.length) {
+          attrs['codex.files_changed'] = item.changes.length;
+          // Sanitize paths to remove usernames/PII and truncate total length
+          const sanitizedPaths = item.changes.map((c: any) => this.sanitizePath(c.path));
+          attrs['codex.files'] = sanitizedPaths.join(', ').slice(0, 500);
+        }
+        break;
+      case 'mcp_tool_call':
+        if (item.status) attrs['codex.status'] = item.status;
+        if (item.error?.message) attrs['codex.error'] = this.sanitizeText(item.error.message, 500);
+        break;
+      case 'agent_message':
+        // Sanitize and truncate message
+        if (item.text) attrs['codex.message'] = this.sanitizeText(item.text, 500);
+        break;
+      case 'reasoning':
+        // Sanitize and truncate reasoning
+        if (item.text) attrs['codex.reasoning'] = this.sanitizeText(item.text, 500);
+        break;
+      case 'error':
+        if (item.message) attrs['codex.error'] = this.sanitizeText(item.message, 500);
+        break;
+    }
+
+    return attrs;
+  }
+
   private generateCacheKey(config: OpenAICodexSDKConfig, prompt: string): string {
     const keyData = {
       working_dir: config.working_dir,
@@ -482,8 +819,110 @@ export class OpenAICodexSDKProvider implements ApiProvider {
       ...context?.prompt?.config,
     };
 
-    // Prepare environment
-    const env: Record<string, string> = this.prepareEnvironment(config);
+    const modelName = config.model || 'codex';
+
+    // Build GenAI span context for tracing
+    const spanContext: GenAISpanContext = {
+      system: 'openai',
+      operationName: 'chat',
+      model: modelName,
+      providerId: this.id(),
+      evalId: context?.evaluationId || context?.test?.metadata?.evaluationId,
+      testIndex: context?.test?.vars?.__testIdx as number | undefined,
+      promptLabel: context?.prompt?.label,
+      traceparent: context?.traceparent,
+      requestBody: prompt,
+    };
+
+    // Result extractor for span attributes
+    const resultExtractor = (response: ProviderResponse): GenAISpanResult => {
+      const result: GenAISpanResult = {};
+
+      if (response.tokenUsage) {
+        result.tokenUsage = response.tokenUsage;
+      }
+
+      // Surface session/thread ID for debugging provider reuse
+      if (response.sessionId) {
+        result.responseId = response.sessionId;
+      }
+
+      // Surface cache status if available
+      if (response.cached !== undefined) {
+        result.cacheHit = response.cached;
+      }
+
+      // Confirm actual model used (may differ from requested)
+      result.responseModel = modelName;
+
+      if (response.output !== undefined) {
+        result.responseBody =
+          typeof response.output === 'string' ? response.output : JSON.stringify(response.output);
+      }
+
+      // Extract reasoning summary from raw response if available
+      if (response.raw) {
+        try {
+          const rawData = typeof response.raw === 'string' ? JSON.parse(response.raw) : response.raw;
+          // Include reasoning in additional attributes
+          if (rawData.reasoningTexts?.length > 0) {
+            result.additionalAttributes = {
+              'codex.reasoning.count': rawData.reasoningTexts.length,
+              'codex.reasoning.summary': rawData.reasoningTexts.join('\n---\n').slice(0, 2000),
+            };
+          }
+          // Include conversation history
+          if (rawData.conversationMessages?.length > 0) {
+            result.additionalAttributes = {
+              ...result.additionalAttributes,
+              'codex.conversation.message_count': rawData.conversationMessages.length,
+            };
+          }
+          // Include item counts for observability
+          if (rawData.items?.length > 0) {
+            const itemCounts: Record<string, number> = {};
+            for (const item of rawData.items) {
+              itemCounts[item.type] = (itemCounts[item.type] || 0) + 1;
+            }
+            result.additionalAttributes = {
+              ...result.additionalAttributes,
+              'codex.items.total': rawData.items.length,
+              'codex.items.breakdown': JSON.stringify(itemCounts),
+            };
+          }
+        } catch {
+          // Ignore parse errors
+        }
+      }
+
+      return result;
+    };
+
+    // Wrap the API call in a GenAI span
+    return withGenAISpan(
+      spanContext,
+      () => this.callApiInternal(prompt, context, callOptions, config),
+      resultExtractor,
+    );
+  }
+
+  /**
+   * Internal implementation of callApi without tracing wrapper.
+   * Context is available for future use (e.g., _context?.vars for template rendering,
+   * _context?.bustCache for cache control, _context?.debug for debug mode).
+   */
+  private async callApiInternal(
+    prompt: string,
+    _context: CallApiContextParams | undefined,
+    callOptions: CallApiOptionsParams | undefined,
+    config: OpenAICodexSDKConfig,
+  ): Promise<ProviderResponse> {
+    // Get current trace context for deep tracing
+    // This allows the Codex CLI to export its internal spans as children of our span
+    const currentTraceparent = getTraceparent();
+
+    // Prepare environment with OTEL config for deep tracing
+    const env: Record<string, string> = this.prepareEnvironment(config, currentTraceparent);
 
     if (!this.apiKey && !env.OPENAI_API_KEY && !env.CODEX_API_KEY) {
       throw new Error(
@@ -506,13 +945,60 @@ export class OpenAICodexSDKProvider implements ApiProvider {
       this.codexModule = await loadCodexSDK();
     }
 
-    // Initialize Codex instance (lazy)
-    if (!this.codexInstance) {
+    // Compute hash of environment for instance caching
+    // Note: deep_tracing is INCOMPATIBLE with thread persistence
+    // The CLI only sees TRACEPARENT at spawn time - subsequent calls would have wrong parent span
+    // When deep_tracing is enabled, we MUST recreate the instance for each call to get correct spans
+    const stableEnv = { ...env };
+    if (config.deep_tracing) {
+      // Keep full TRACEPARENT in hash - forces instance recreation per-call
+      // This ensures each call's child spans are correctly linked to the right parent span
+      // Thread persistence (persist_threads, thread_id, thread_pool_size) is disabled in this mode
+      if (
+        (config.persist_threads || config.thread_id || (config.thread_pool_size ?? 0) > 1) &&
+        !this.deepTracingWarningShown
+      ) {
+        logger.warn(
+          '[CodexSDK] deep_tracing is incompatible with thread persistence. ' +
+            'Thread options (persist_threads, thread_id, thread_pool_size) are ignored when deep_tracing is enabled.',
+        );
+        this.deepTracingWarningShown = true;
+      }
+    } else {
+      // When NOT doing deep tracing, exclude TRACEPARENT entirely
+      // This preserves thread persistence across traces
+      delete stableEnv.TRACEPARENT;
+    }
+    // OTEL config vars stay in hash - they're configuration, not per-request context
+    const envHash = crypto.createHash('sha256').update(JSON.stringify(stableEnv)).digest('hex');
+    const envChanged = this.codexInstanceEnvHash !== envHash;
+
+    // Initialize Codex instance - recreate only if stable config changed
+    if (!this.codexInstance || envChanged) {
+      if (envChanged && this.codexInstance) {
+        logger.debug('[CodexSDK] Recreating instance due to configuration change');
+        // Clean up old instance to prevent resource leaks
+        try {
+          if (typeof this.codexInstance.destroy === 'function') {
+            await this.codexInstance.destroy();
+          } else if (typeof this.codexInstance.cleanup === 'function') {
+            await this.codexInstance.cleanup();
+          } else if (typeof this.codexInstance.close === 'function') {
+            await this.codexInstance.close();
+          }
+        } catch (cleanupError) {
+          logger.warn('[CodexSDK] Error cleaning up old instance', { error: cleanupError });
+        }
+        // Clear thread pool when instance is recreated
+        this.threads.clear();
+      }
+      // Create new instance with full environment (including TRACEPARENT for initial trace linking)
       this.codexInstance = new this.codexModule.Codex({
         env,
         ...(config.codex_path_override ? { codexPathOverride: config.codex_path_override } : {}),
         ...(config.base_url ? { baseUrl: config.base_url } : {}),
       });
+      this.codexInstanceEnvHash = envHash;
     }
 
     // Get or create thread
diff --git a/src/tracing/genaiTracer.ts b/src/tracing/genaiTracer.ts
index b1e9e1b04..9eceaccfc 100644
--- a/src/tracing/genaiTracer.ts
+++ b/src/tracing/genaiTracer.ts
@@ -152,6 +152,8 @@ export interface GenAISpanResult {
   cacheHit?: boolean;
   /** Response body (will be truncated to MAX_BODY_LENGTH) */
   responseBody?: string;
+  /** Additional provider-specific attributes to add to the span */
+  additionalAttributes?: Record<string, string | number | boolean>;
 }
 
 /**
@@ -316,7 +318,7 @@ function buildRequestAttributes(ctx: GenAISpanContext): Attributes {
  * Sanitize sensitive data from a body string.
  * Redacts API keys, secrets, tokens, and other sensitive patterns.
  */
-function sanitizeBody(body: string): string {
+export function sanitizeBody(body: string): string {
   let sanitized = body;
   for (const { pattern, replacement } of SENSITIVE_PATTERNS) {
     if (typeof replacement === 'function') {
@@ -419,6 +421,21 @@ export function setGenAIResponseAttributes(
       truncateBody(result.responseBody, sanitize),
     );
   }
+
+  // Provider-specific additional attributes
+  // Apply same sanitization/truncation as request/response bodies to prevent secret leakage
+  if (result.additionalAttributes) {
+    for (const [key, value] of Object.entries(result.additionalAttributes)) {
+      if (value !== undefined && value !== null) {
+        // Sanitize string values (e.g., reasoning text, conversation content)
+        if (typeof value === 'string') {
+          span.setAttribute(key, truncateBody(value, sanitize));
+        } else {
+          span.setAttribute(key, value);
+        }
+      }
+    }
+  }
 }
 
 /**
