import React, { useCallback, useState } from 'react';
import { callApi } from '@app/utils/api';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import KeyboardArrowLeftIcon from '@mui/icons-material/KeyboardArrowLeft';
import KeyboardArrowRightIcon from '@mui/icons-material/KeyboardArrowRight';
import {
  Typography,
  TextField,
  Button,
  Box,
  IconButton,
  Stack,
  Grid,
  Tooltip,
  Switch,
  FormControlLabel,
} from '@mui/material';
import CircularProgress from '@mui/material/CircularProgress';
import { useDebouncedCallback } from 'use-debounce';
import { useRedTeamConfig } from '../hooks/useRedTeamConfig.ts';
import Entities from './EntitiesPicker.tsx';

interface PromptsProps {
  onNext: () => void;
  onBack: () => void;
}

const promptExamples = {
  default: 'You are a helpful assistant. User query: {{ prompt }}',
};

export default function Prompts({ onNext, onBack }: PromptsProps) {
  const { config, updateConfig } = useRedTeamConfig();
  const needsCustomPrompt = config.target.id !== 'http' && config.target.id !== 'websocket';
  const [isAutoGenerated, setIsAutoGenerated] = useState(needsCustomPrompt);
  const [isLoading, setIsLoading] = useState(false);

  const addPrompt = () => {
    const newPrompts = [...config.prompts, promptExamples.default];
    updateConfig('prompts', newPrompts);
  };

  const debouncedUpdatePurposeAndEntities = useDebouncedCallback(async (prompts: string[]) => {
    setIsLoading(true);
    try {
      const [purposeResponse, entitiesResponse] = await Promise.all([
        callApi('/redteam/purpose', {
          method: 'POST',
          body: JSON.stringify({ prompts }),
          headers: {
            'Content-Type': 'application/json',
          },
        }),
        callApi('/redteam/entities', {
          method: 'POST',
          body: JSON.stringify({ prompts }),
          headers: {
            'Content-Type': 'application/json',
          },
        }),
      ]);
      const purposeData = await purposeResponse.json();
      const entitiesData = await entitiesResponse.json();
      updateConfig('purpose', purposeData.result);
      updateConfig('entities', entitiesData.result);
    } catch (error) {
      console.error('Failed to calculate purpose or entities:', error);
    } finally {
      setIsLoading(false);
    }
  }, 1000);

  const updatePrompt = useCallback(
    (index: number, value: string) => {
      const newPrompts = [...config.prompts];
      newPrompts[index] = value;
      updateConfig('prompts', newPrompts);

      // Debounce the API call to update the purpose and entities
      const nonEmptyPrompts = newPrompts.filter((prompt) => prompt.trim() !== '');
      if (nonEmptyPrompts.length > 0) {
        debouncedUpdatePurposeAndEntities(nonEmptyPrompts.map((prompt) => prompt.trim()));
      } else {
        // If all prompts are empty, clear the purpose and entities immediately
        updateConfig('purpose', '');
        updateConfig('entities', []);
      }
    },
    [config.prompts, updateConfig, debouncedUpdatePurposeAndEntities],
  );

  const removePrompt = useCallback(
    (index: number) => {
      const newPrompts = config.prompts.filter((_, i) => i !== index);
      updateConfig('prompts', newPrompts);

      // Check if there are any non-empty prompts left after removal
      const nonEmptyPrompts = newPrompts.filter((prompt) => prompt !== '');
      if (nonEmptyPrompts.length > 0) {
        debouncedUpdatePurposeAndEntities(nonEmptyPrompts);
      } else {
        // Clear the purpose and entities if there are no valid prompts left
        updateConfig('purpose', '');
        updateConfig('entities', []);
      }
    },
    [config.prompts, updateConfig, debouncedUpdatePurposeAndEntities],
  );

  const handlePurposeChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newPurpose = event.target.value;
    if (isAutoGenerated) {
      setIsAutoGenerated(false);
    }
    updateConfig('purpose', newPurpose);
  };

  const handleAutoGeneratedToggle = (event: React.ChangeEvent<HTMLInputElement>) => {
    const isChecked = event.target.checked;
    setIsAutoGenerated(isChecked);
    if (isChecked) {
      const nonEmptyPrompts = config.prompts.filter((prompt) => prompt.trim() !== '');
      if (nonEmptyPrompts.length > 0) {
        debouncedUpdatePurposeAndEntities(nonEmptyPrompts);
      }
    }
  };

  const isPurposePresent = config.purpose && config.purpose.trim() !== '';

  return (
    <Stack direction="column" spacing={4}>
      <Typography variant="h4" gutterBottom sx={{ fontWeight: 'bold', mb: 3 }}>
        Application Details
      </Typography>
      {needsCustomPrompt && (
        <Box>
          <Typography variant="h5" gutterBottom sx={{ fontWeight: 'medium' }}>
            Prompts
          </Typography>
          <Typography variant="body1" paragraph>
            {`Enter your prompts below. Use {{ prompt }} as a placeholder for user input.`}
          </Typography>
          {config.prompts.map((prompt, index) => (
            <Box key={index} display="flex" alignItems="center" mb={2}>
              <TextField
                fullWidth
                label={`Prompt ${index + 1}`}
                value={prompt}
                onChange={(e) => updatePrompt(index, e.target.value)}
                margin="normal"
                multiline
                rows={3}
                sx={{ backgroundColor: '#ffffff' }}
              />
              <Tooltip title="Remove prompt">
                <IconButton onClick={() => removePrompt(index)}>
                  <DeleteIcon />
                </IconButton>
              </Tooltip>
            </Box>
          ))}
          <Button startIcon={<AddIcon />} onClick={addPrompt} variant="outlined">
            Add Prompt
          </Button>
        </Box>
      )}

      <Box>
        {needsCustomPrompt && (
          <Box display="flex" alignItems="center" mb={3}>
            <FormControlLabel
              control={
                <Switch
                  checked={isAutoGenerated}
                  onChange={handleAutoGeneratedToggle}
                  name="autoGenerated"
                  color="primary"
                />
              }
              label={
                <Typography variant="body1" sx={{ fontWeight: 'medium' }}>
                  Auto-generate details
                </Typography>
              }
            />
            {isLoading && <CircularProgress size={20} sx={{ ml: 2 }} />}
          </Box>
        )}

        <Stack direction="column" spacing={3}>
          <Box>
            <Typography variant="h5" gutterBottom sx={{ fontWeight: 'medium' }}>
              Purpose
            </Typography>
            <Typography variant="body1">
              This is a sentence or two that describes your application.
            </Typography>
            <TextField
              fullWidth
              value={config.purpose}
              onChange={handlePurposeChange}
              placeholder="e.g. You are a travel agent specialized in budget trips to Europe"
              margin="normal"
              multiline
              rows={4}
              sx={{ backgroundColor: '#ffffff' }}
            />
            {needsCustomPrompt && (
              <Typography variant="body1" color="text.secondary" mt={1}>
                {isAutoGenerated
                  ? 'This purpose is automatically generated based on your prompts'
                  : 'This purpose has been manually edited and is no longer automatically updated'}
              </Typography>
            )}
          </Box>

          <Box>
            <Typography variant="h5" gutterBottom sx={{ fontWeight: 'medium' }}>
              Entities
            </Typography>
            <Entities
              entities={config.entities}
              autoGenerate={isAutoGenerated}
              updateEntities={(newEntities: string[]) => {
                updateConfig('entities', newEntities);
              }}
              prompts={config.prompts}
            />
          </Box>
        </Stack>

        <Grid item xs={12}>
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              mt: 4,
            }}
          >
            <Button
              variant="outlined"
              startIcon={<KeyboardArrowLeftIcon />}
              onClick={onBack}
              sx={{
                px: 4,
                py: 1,
              }}
            >
              Back
            </Button>
            <Button
              variant="contained"
              endIcon={<KeyboardArrowRightIcon />}
              onClick={onNext}
              disabled={!isPurposePresent}
              sx={{
                backgroundColor: '#3498db',
                '&:hover': { backgroundColor: '#2980b9' },
                '&:disabled': { backgroundColor: '#bdc3c7' },
                px: 4,
                py: 1,
              }}
            >
              Next
            </Button>
          </Box>
        </Grid>
      </Box>
    </Stack>
  );
}
