import {
  DEFAULT_APPLICATION_DEFINITION,
  SECTION_HEADER_TO_FIELD,
} from '@promptfoo/validators/recon-constants';

import type { ApplicationDefinition } from '../types';

/**
 * Parses a formatted purpose string back into an ApplicationDefinition object.
 *
 * The purpose string is expected to be in the format generated by
 * `applicationDefinitionToPurpose()`:
 *
 * ```
 * Application Purpose:
 * \`\`\`
 * content here
 * \`\`\`
 *
 * Key Features and Capabilities:
 * \`\`\`
 * more content
 * \`\`\`
 * ```
 *
 * If the string doesn't match this format, it falls back to treating
 * the entire string as the purpose field.
 *
 * @param purpose - The formatted purpose string from YAML
 * @returns ApplicationDefinition with parsed fields
 */
export function purposeToApplicationDefinition(purpose: string | undefined): ApplicationDefinition {
  // Handle null/undefined/empty cases
  if (!purpose || typeof purpose !== 'string') {
    return { ...DEFAULT_APPLICATION_DEFINITION };
  }

  // Normalize line endings (CRLF -> LF) for cross-platform compatibility
  const normalizedPurpose = purpose.replace(/\r\n/g, '\n');

  const trimmedPurpose = normalizedPurpose.trim();
  if (!trimmedPurpose) {
    return { ...DEFAULT_APPLICATION_DEFINITION };
  }

  const result: ApplicationDefinition = { ...DEFAULT_APPLICATION_DEFINITION };

  // Try to parse structured format with code blocks
  // Pattern: "Section Title:\n```\ncontent\n```"
  // Using a more robust regex that handles various edge cases
  const sectionRegex = /([A-Za-z][A-Za-z0-9\s/']+?):\s*\n```\n([\s\S]*?)\n```/g;

  let match;
  let foundAnySection = false;

  while ((match = sectionRegex.exec(trimmedPurpose)) !== null) {
    const [, sectionTitle, content] = match;
    const normalizedTitle = sectionTitle.trim();
    const field = SECTION_HEADER_TO_FIELD[normalizedTitle];

    if (field) {
      result[field] = content.trim();
      foundAnySection = true;
    }
  }

  // If we found structured sections, return the parsed result
  if (foundAnySection) {
    return result;
  }

  // Fallback 1: Try alternative format without code blocks
  // Pattern: "Section Title:\nContent until next section or end"
  const alternativeRegex =
    /([A-Za-z][A-Za-z0-9\s/']+?):\s*\n([^\n][\s\S]*?)(?=\n[A-Za-z][A-Za-z0-9\s/']+?:\s*\n|$)/g;

  while ((match = alternativeRegex.exec(trimmedPurpose)) !== null) {
    const [, sectionTitle, content] = match;
    const normalizedTitle = sectionTitle.trim();
    const field = SECTION_HEADER_TO_FIELD[normalizedTitle];

    if (field) {
      result[field] = content.trim();
      foundAnySection = true;
    }
  }

  if (foundAnySection) {
    return result;
  }

  // Fallback 2: Treat entire string as the purpose field
  // This handles plain text purposes that weren't generated by the UI
  result.purpose = trimmedPurpose;

  return result;
}

/**
 * Checks if an ApplicationDefinition has any meaningful content
 */
export function hasApplicationDefinitionContent(
  appDef: ApplicationDefinition | undefined,
): boolean {
  if (!appDef) {
    return false;
  }

  return Object.values(appDef).some((value) => value && typeof value === 'string' && value.trim());
}

/**
 * Merges a parsed ApplicationDefinition with defaults, ensuring all fields exist
 */
export function mergeWithDefaults(parsed: Partial<ApplicationDefinition>): ApplicationDefinition {
  return {
    ...DEFAULT_APPLICATION_DEFINITION,
    ...parsed,
  };
}
