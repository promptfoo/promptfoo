import type { ApplicationDefinition } from '../types';

/**
 * Mapping from section headers in the formatted purpose string
 * to ApplicationDefinition field names.
 *
 * These headers are generated by `applicationDefinitionToPurpose()` in useRedTeamConfig.ts
 */
const SECTION_MAPPINGS: Record<string, keyof ApplicationDefinition> = {
  'Application Purpose': 'purpose',
  'Key Features and Capabilities': 'features',
  'Industry/Domain': 'industry',
  'System Rules and Constraints for Attackers': 'attackConstraints',
  'Systems and Data the Application Has Access To': 'hasAccessTo',
  'Systems and Data the Application Should NOT Have Access To': 'doesNotHaveAccessTo',
  'Types of Users Who Interact with the Application': 'userTypes',
  'Security and Compliance Requirements': 'securityRequirements',
  'Types of Sensitive Data Handled': 'sensitiveDataTypes',
  'Example Data Identifiers and Formats': 'exampleIdentifiers',
  'Critical or Dangerous Actions the Application Can Perform': 'criticalActions',
  'Content and Topics the Application Should Never Discuss': 'forbiddenTopics',
  'Competitors That Should Not Be Endorsed': 'competitors',
  'Red Team User Persona': 'redteamUser',
  'Data You Have Access To': 'accessToData',
  'Data You Do Not Have Access To': 'forbiddenData',
  'Actions You Can Take': 'accessToActions',
  'Actions You Should Not Take': 'forbiddenActions',
  'Connected Systems the LLM Agent Has Access To': 'connectedSystems',
};

/**
 * Default empty ApplicationDefinition for fallback cases
 */
const DEFAULT_APPLICATION_DEFINITION: ApplicationDefinition = {
  purpose: '',
  features: '',
  hasAccessTo: '',
  doesNotHaveAccessTo: '',
  userTypes: '',
  securityRequirements: '',
  exampleIdentifiers: '',
  industry: '',
  sensitiveDataTypes: '',
  criticalActions: '',
  forbiddenTopics: '',
  competitors: '',
  redteamUser: '',
  accessToData: '',
  forbiddenData: '',
  accessToActions: '',
  forbiddenActions: '',
  connectedSystems: '',
  attackConstraints: '',
};

/**
 * Parses a formatted purpose string back into an ApplicationDefinition object.
 *
 * The purpose string is expected to be in the format generated by
 * `applicationDefinitionToPurpose()`:
 *
 * ```
 * Application Purpose:
 * \`\`\`
 * content here
 * \`\`\`
 *
 * Key Features and Capabilities:
 * \`\`\`
 * more content
 * \`\`\`
 * ```
 *
 * If the string doesn't match this format, it falls back to treating
 * the entire string as the purpose field.
 *
 * @param purpose - The formatted purpose string from YAML
 * @returns ApplicationDefinition with parsed fields
 */
export function purposeToApplicationDefinition(purpose: string | undefined): ApplicationDefinition {
  // Handle null/undefined/empty cases
  if (!purpose || typeof purpose !== 'string') {
    return { ...DEFAULT_APPLICATION_DEFINITION };
  }

  // Normalize line endings (CRLF -> LF) for cross-platform compatibility
  const normalizedPurpose = purpose.replace(/\r\n/g, '\n');

  const trimmedPurpose = normalizedPurpose.trim();
  if (!trimmedPurpose) {
    return { ...DEFAULT_APPLICATION_DEFINITION };
  }

  const result: ApplicationDefinition = { ...DEFAULT_APPLICATION_DEFINITION };

  // Try to parse structured format with code blocks
  // Pattern: "Section Title:\n```\ncontent\n```"
  // Using a more robust regex that handles various edge cases
  const sectionRegex = /([A-Za-z][A-Za-z0-9\s/']+?):\s*\n```\n([\s\S]*?)\n```/g;

  let match;
  let foundAnySection = false;

  while ((match = sectionRegex.exec(trimmedPurpose)) !== null) {
    const [, sectionTitle, content] = match;
    const normalizedTitle = sectionTitle.trim();
    const field = SECTION_MAPPINGS[normalizedTitle];

    if (field) {
      result[field] = content.trim();
      foundAnySection = true;
    }
  }

  // If we found structured sections, return the parsed result
  if (foundAnySection) {
    return result;
  }

  // Fallback 1: Try alternative format without code blocks
  // Pattern: "Section Title:\nContent until next section or end"
  const alternativeRegex =
    /([A-Za-z][A-Za-z0-9\s/']+?):\s*\n([^\n][\s\S]*?)(?=\n[A-Za-z][A-Za-z0-9\s/']+?:\s*\n|$)/g;

  while ((match = alternativeRegex.exec(trimmedPurpose)) !== null) {
    const [, sectionTitle, content] = match;
    const normalizedTitle = sectionTitle.trim();
    const field = SECTION_MAPPINGS[normalizedTitle];

    if (field) {
      result[field] = content.trim();
      foundAnySection = true;
    }
  }

  if (foundAnySection) {
    return result;
  }

  // Fallback 2: Treat entire string as the purpose field
  // This handles plain text purposes that weren't generated by the UI
  result.purpose = trimmedPurpose;

  return result;
}

/**
 * Checks if an ApplicationDefinition has any meaningful content
 */
export function hasApplicationDefinitionContent(
  appDef: ApplicationDefinition | undefined,
): boolean {
  if (!appDef) {
    return false;
  }

  return Object.values(appDef).some((value) => value && typeof value === 'string' && value.trim());
}

/**
 * Merges a parsed ApplicationDefinition with defaults, ensuring all fields exist
 */
export function mergeWithDefaults(parsed: Partial<ApplicationDefinition>): ApplicationDefinition {
  return {
    ...DEFAULT_APPLICATION_DEFINITION,
    ...parsed,
  };
}
