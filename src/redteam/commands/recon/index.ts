import * as fs from 'fs';
import * as path from 'path';

import chalk from 'chalk';
import confirm from '@inquirer/confirm';
import open from 'open';
import ora from 'ora';

import logger from '../../../logger';
import { getConfigDirectoryPath } from '../../../util/config/manage';
import { writePromptfooConfig } from '../../../util/config/writer';
import { buildRedteamConfig } from './config';
import { buildReconPrompt } from './prompt';
import {
  selectProvider,
  createOpenAIReconProvider,
  createAnthropicReconProvider,
  type ReconProgressCallback,
} from './providers';
import { createScratchpad } from './scratchpad';
import type { ReconOptions, ReconResult } from './types';

/** Default port for the promptfoo web server */
const DEFAULT_SERVER_PORT = 15500;

/** Filename for pending recon config */
const PENDING_RECON_FILENAME = 'pending-recon.json';

/**
 * Writes the recon result to a pending file for the web UI to pick up.
 * This enables the CLI → Browser handoff flow.
 */
function writePendingReconConfig(
  config: object,
  result: ReconResult,
  codebaseDirectory: string,
): string {
  const configDir = getConfigDirectoryPath(true);
  const pendingPath = path.join(configDir, PENDING_RECON_FILENAME);

  const pendingData = {
    config,
    metadata: {
      source: 'recon-cli' as const,
      timestamp: Date.now(),
      codebaseDirectory,
      filesAnalyzed: result.keyFiles?.length || 0,
    },
    reconResult: result,
  };

  fs.writeFileSync(pendingPath, JSON.stringify(pendingData, null, 2));
  logger.debug(`Wrote pending recon config to ${pendingPath}`);

  return pendingPath;
}

/**
 * Opens the web UI with the recon source parameter
 */
async function openBrowserWithRecon(): Promise<void> {
  const url = `http://localhost:${DEFAULT_SERVER_PORT}/redteam/setup?source=recon`;

  try {
    await open(url);
    logger.info(`\n${chalk.green('✨')} Opening browser: ${chalk.cyan(url)}`);
  } catch (error) {
    logger.debug('Failed to open browser automatically', { error });
    logger.info(`\nOpen this URL in your browser: ${chalk.cyan(url)}`);
  }
}

/**
 * Main entry point for the recon command
 */
export async function doRecon(options: ReconOptions): Promise<ReconResult> {
  const directory = path.resolve(options.dir || process.cwd());

  // Validate directory
  if (!fs.existsSync(directory)) {
    throw new Error(`Directory not found: ${directory}`);
  }
  if (!fs.statSync(directory).isDirectory()) {
    throw new Error(`Path is not a directory: ${directory}`);
  }

  // Create scratchpad for agent notes
  const scratchpad = createScratchpad();

  logger.info(`\nReconnaissance target: ${chalk.cyan(directory)}`);
  logger.info(chalk.dim('Agent can read files, search web, and take notes\n'));

  // Select provider based on available API keys or forced choice
  const providerChoice = selectProvider(options.provider);
  logger.info(`Provider: ${chalk.cyan(providerChoice.type)} (${providerChoice.model})`);

  // Create the appropriate provider with progress callback
  const modelOverride = options.model || providerChoice.model;

  // Run analysis with spinner
  const spinner = ora('Analyzing codebase...').start();

  // Progress callback updates the spinner text
  const onProgress: ReconProgressCallback = (event) => {
    spinner.text = event.message;
  };

  const provider =
    providerChoice.type === 'openai'
      ? await createOpenAIReconProvider(directory, scratchpad, modelOverride, onProgress)
      : await createAnthropicReconProvider(directory, scratchpad, modelOverride, onProgress);

  // Build the analysis prompt
  const prompt = buildReconPrompt(scratchpad.path, options.exclude);

  try {
    const result = await provider.analyze(directory, prompt);
    spinner.succeed('Analysis complete');

    // Display summary of findings
    displayResults(result, options.verbose);

    // Confirm before writing config file
    const outputPath = options.output || 'promptfooconfig.yaml';
    if (!options.yes) {
      const confirmed = await confirm({
        message: `Write config to ${outputPath}?`,
        default: true,
      });
      if (!confirmed) {
        logger.info('Aborted. No config file written.');
        return result;
      }
    }

    // Generate and write the config (pass directory to include metadata for UI import)
    const config = buildRedteamConfig(result, directory);
    writePromptfooConfig(config, outputPath, [
      'Auto-generated by: promptfoo redteam recon',
      `Scanned directory: ${directory}`,
      `Generated: ${new Date().toISOString()}`,
      '',
      'Review this config and configure your target before running:',
      '  promptfoo redteam run',
    ]);

    logger.info(`\nConfig written to ${chalk.green(outputPath)}`);

    // Write pending recon config for web UI handoff
    writePendingReconConfig(config, result, directory);

    // Open browser if not disabled
    if (options.open !== false) {
      await openBrowserWithRecon();
      logger.info(chalk.dim('Configure your target in the browser, then click Run.'));
    } else {
      logger.info(`\n${chalk.yellow('Next steps:')}`);
      logger.info('  1. Configure your target endpoint in the config');
      logger.info('  2. Review the discovered application context');
      logger.info(`  3. Run: ${chalk.cyan('promptfoo redteam run')}`);
    }

    return result;
  } finally {
    // Always cleanup scratchpad
    scratchpad.cleanup();
  }
}

/**
 * Displays the reconnaissance results to the console
 */
function displayResults(result: ReconResult, verbose?: boolean): void {
  logger.info(chalk.bold.green('\n=== Reconnaissance Results ===\n'));

  if (result.purpose) {
    logger.info(chalk.bold('Purpose:'));
    logger.info(`  ${result.purpose}\n`);
  }

  if (result.features) {
    logger.info(chalk.bold('Features:'));
    logger.info(`  ${result.features}\n`);
  }

  if (result.industry) {
    logger.info(chalk.bold('Industry:'));
    logger.info(`  ${result.industry}\n`);
  }

  if (result.systemPrompt) {
    logger.info(chalk.bold('System Prompt Found:'));
    const truncated =
      result.systemPrompt.length > 200
        ? `${result.systemPrompt.substring(0, 200)}...`
        : result.systemPrompt;
    logger.info(chalk.dim(`  ${truncated}`));
    logger.info('');
  }

  if (result.hasAccessTo) {
    logger.info(chalk.bold('Has Access To:'));
    logger.info(`  ${result.hasAccessTo}\n`);
  }

  if (result.discoveredTools && result.discoveredTools.length > 0) {
    logger.info(chalk.bold(`Discovered Tools (${result.discoveredTools.length}):`));
    for (const tool of result.discoveredTools) {
      logger.info(`  - ${tool.name}: ${tool.description}`);
      if (tool.file && verbose) {
        logger.info(chalk.dim(`    File: ${tool.file}`));
      }
    }
    logger.info('');
  }

  if (result.suggestedPlugins && result.suggestedPlugins.length > 0) {
    logger.info(chalk.bold('Suggested Plugins:'));
    logger.info(`  ${result.suggestedPlugins.join(', ')}\n`);
  }

  if (result.entities && result.entities.length > 0) {
    logger.info(chalk.bold('Entities:'));
    logger.info(`  ${result.entities.join(', ')}\n`);
  }

  if (result.securityNotes && result.securityNotes.length > 0) {
    logger.info(chalk.bold.yellow('Security Notes:'));
    for (const note of result.securityNotes) {
      logger.info(`  - ${note}`);
    }
    logger.info('');
  }

  if (verbose && result.keyFiles && result.keyFiles.length > 0) {
    logger.info(chalk.bold('Key Files Analyzed:'));
    for (const file of result.keyFiles) {
      logger.info(`  ${file}`);
    }
  }
}

// Re-export types for external use
export type { ReconOptions, ReconResult } from './types';
