import * as fs from 'fs';
import * as path from 'path';

import confirm from '@inquirer/confirm';
import chalk from 'chalk';
import open from 'open';
import ora from 'ora';
import { getLocalAppUrl } from '../../../constants';
import logger from '../../../logger';
import { writePromptfooConfig } from '../../../util/config/writer';
import { buildRedteamConfig } from './config';
import { displayResults } from './output';
import { buildPendingConfig, writePendingReconConfig } from './pending';
import { buildReconPrompt } from './prompt';
import {
  createAnthropicReconProvider,
  createOpenAIReconProvider,
  type ReconProgressCallback,
  selectProvider,
} from './providers';
import { createScratchpad } from './scratchpad';

import type { ReconOptions, ReconResult } from './types';

/**
 * Opens the web UI with the recon source parameter
 */
async function openBrowserWithRecon(): Promise<void> {
  const url = getLocalAppUrl('/redteam/setup', { source: 'recon' });

  try {
    await open(url);
    logger.info(`\n${chalk.green('âœ¨')} Opening browser: ${chalk.cyan(url)}`);
  } catch (error) {
    logger.debug('Failed to open browser automatically', { error });
    logger.info(`\nOpen this URL in your browser: ${chalk.cyan(url)}`);
  }
}

/**
 * Main entry point for the recon command
 */
export async function doRecon(options: ReconOptions): Promise<ReconResult> {
  const directory = path.resolve(options.dir || process.cwd());

  // Validate directory
  if (!fs.existsSync(directory)) {
    throw new Error(`Directory not found: ${directory}`);
  }
  if (!fs.statSync(directory).isDirectory()) {
    throw new Error(`Path is not a directory: ${directory}`);
  }

  // Create scratchpad for agent notes
  const scratchpad = createScratchpad();

  logger.info(`\nReconnaissance target: ${chalk.cyan(directory)}`);
  logger.info(chalk.dim('Agent can read files, search web, and take notes\n'));

  // Select provider based on available API keys or forced choice
  const providerChoice = selectProvider(options.provider);
  logger.info(`Provider: ${chalk.cyan(providerChoice.type)} (${providerChoice.model})`);

  // Create the appropriate provider with progress callback
  const modelOverride = options.model || providerChoice.model;

  // Run analysis with spinner
  const spinner = ora('Analyzing codebase...').start();

  // Progress callback updates the spinner text
  const onProgress: ReconProgressCallback = (event) => {
    spinner.text = event.message;
  };

  const provider =
    providerChoice.type === 'openai'
      ? await createOpenAIReconProvider(directory, scratchpad, modelOverride, onProgress)
      : await createAnthropicReconProvider(directory, scratchpad, modelOverride, onProgress);

  // Build the analysis prompt
  const prompt = buildReconPrompt(scratchpad.path, options.exclude);

  try {
    const result = await provider.analyze(directory, prompt);
    spinner.succeed('Analysis complete');

    // Display summary of findings
    displayResults(result, options.verbose);

    // Confirm before writing config file
    const outputPath = options.output || 'promptfooconfig.yaml';
    if (!options.yes) {
      const confirmed = await confirm({
        message: `Write config to ${outputPath}?`,
        default: true,
      });
      if (!confirmed) {
        logger.info('Aborted. No config file written.');
        return result;
      }
    }

    // Generate and write the config (pass directory to include metadata for UI import)
    const config = buildRedteamConfig(result, directory);
    writePromptfooConfig(config, outputPath, [
      'Auto-generated by: promptfoo redteam recon',
      `Scanned directory: ${directory}`,
      `Generated: ${new Date().toISOString()}`,
      '',
      'Review this config and configure your target before running:',
      '  promptfoo redteam run',
    ]);

    logger.info(`\nConfig written to ${chalk.green(outputPath)}`);

    // Write pending recon config for web UI handoff
    const pendingConfig = buildPendingConfig(config, result, directory);
    writePendingReconConfig(pendingConfig);

    // Open browser if not disabled
    if (options.open !== false) {
      await openBrowserWithRecon();
      logger.info(chalk.dim('Configure your target in the browser, then click Run.'));
    } else {
      logger.info(`\n${chalk.yellow('Next steps:')}`);
      logger.info('  1. Configure your target endpoint in the config');
      logger.info('  2. Review the discovered application context');
      logger.info(`  3. Run: ${chalk.cyan('promptfoo redteam run')}`);
    }

    return result;
  } finally {
    // Always cleanup scratchpad
    scratchpad.cleanup();
  }
}

// Re-export types for external use
export type { ReconOptions, ReconResult } from './types';
