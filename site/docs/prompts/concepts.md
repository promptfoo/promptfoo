# Core Concepts

Understanding the key concepts of Promptfoo's prompt management system will help you leverage its full potential. This guide explains the fundamental building blocks and how they work together.

## Managed Prompts

A **managed prompt** is a prompt that's tracked by the prompt management system. Each managed prompt has:

- **Unique ID**: A human-readable identifier (e.g., `customer-support`)
- **Description**: Optional description of the prompt's purpose
- **Version History**: All changes are tracked with timestamps and authors
- **Metadata**: Tags, labels, and custom metadata
- **Deployment Status**: Which versions are deployed where

<!-- ![Managed Prompt Structure](../assets/prompt-structure-diagram.png) -->

### Managed vs Unmanaged Prompts

| Aspect        | Unmanaged Prompts           | Managed Prompts        |
| ------------- | --------------------------- | ---------------------- |
| Storage       | Inline in config files      | Centralized storage    |
| Versioning    | Manual via Git              | Automatic versioning   |
| Reference     | Direct content or file path | `pf://prompt-id`       |
| Deployment    | No tracking                 | Environment tracking   |
| Collaboration | File-based                  | Built-in collaboration |

## Versions

Every change to a managed prompt creates a new **version**. Versions are:

- **Immutable**: Once created, a version cannot be changed
- **Sequential**: Numbered starting from 1
- **Timestamped**: Creation time is recorded
- **Attributed**: Author information is stored

<!-- ![Version Timeline](../assets/prompt-version-timeline.png) -->

### Version Properties

```yaml
version:
  number: 3
  author: user@example.com
  createdAt: 2024-01-15T10:30:00Z
  notes: 'Added error handling instructions'
  content: 'You are a helpful assistant...'
  config:
    temperature: 0.7
    max_tokens: 1000
  contentType: 'string' # or "json", "function", "file"
```

## Deployments

A **deployment** maps a specific prompt version to an environment. This enables:

- Different versions in different environments
- Gradual rollouts
- Quick rollbacks
- Environment-specific configurations

<!-- ![Deployment Flow](../assets/prompt-deployment-flow.png) -->

### Common Deployment Patterns

1. **Progressive Deployment**

   ```
   Development → v5 (latest)
   Staging → v4 (testing)
   Production → v3 (stable)
   ```

2. **A/B Testing**

   ```
   Production-A → v3
   Production-B → v4
   ```

3. **Canary Deployment**
   ```
   Production → v3 (90% traffic)
   Production-Canary → v4 (10% traffic)
   ```

## Prompt References

Managed prompts are referenced using the `pf://` protocol:

### Reference Formats

1. **Latest Version**

   ```
   pf://customer-support
   ```

2. **Specific Version**

   ```
   pf://customer-support:3
   ```

3. **Environment Deployment**
   ```
   pf://customer-support:production
   ```

<!-- ![Reference Resolution](../assets/prompt-reference-resolution.png) -->

## Content Types

Managed prompts support various content types:

### 1. String Prompts

Basic text prompts with variable substitution:

```yaml
contentType: string
content: 'You are a {{role}} assistant for {{company}}'
```

### 2. JSON/Chat Prompts

Structured prompts for chat models:

```yaml
contentType: json
content: |
  [
    {"role": "system", "content": "You are a helpful assistant"},
    {"role": "user", "content": "{{query}}"}
  ]
```

### 3. Function Prompts

Dynamic prompts generated by code:

```yaml
contentType: function
functionSource: |
  module.exports = ({ vars }) => {
    const timeOfDay = new Date().getHours() < 12 ? 'morning' : 'afternoon';
    return `Good ${timeOfDay}, ${vars.name}!`;
  };
```

### 4. File References

Prompts loaded from external files:

```yaml
contentType: file
fileFormat: .yaml
content: 'file://prompts/complex-prompt.yaml'
```

## Configuration

Each prompt version can include configuration that overrides provider defaults:

```yaml
config:
  # Model parameters
  temperature: 0.7
  max_tokens: 1000
  top_p: 0.95

  # Response format
  response_format:
    type: 'json_schema'
    json_schema:
      name: 'analysis'
      schema:
        type: 'object'
        properties:
          sentiment: { type: 'string' }

  # Custom transforms
  transform: |
    return `[INST] ${prompt} [/INST]`
```

<!-- ![Configuration Hierarchy](../assets/prompt-config-hierarchy.png) -->

## Storage Modes

Prompt management supports two storage modes:

### Local Mode

- **Storage**: YAML files in `./prompts/` directory
- **Advantages**:
  - No setup required
  - Git integration
  - Offline access
  - Full control
- **Best for**: Individual developers, small teams

<!-- ![Local Storage Structure](../assets/prompt-local-storage.png) -->

### Cloud Mode

- **Storage**: Centralized database
- **Advantages**:
  - Real-time collaboration
  - Access control
  - Automatic backups
  - Web UI access
- **Best for**: Teams, enterprise deployments

<!-- ![Cloud Architecture](../assets/prompt-cloud-architecture.png) -->

## Auto-Tracking

Auto-tracking automatically creates managed versions of unmanaged prompts:

### How It Works

1. **Detection**: Unmanaged prompts in evaluations are detected
2. **ID Generation**: Unique IDs are generated based on content or labels
3. **Storage**: Prompts are saved to the management system
4. **Reference**: Future runs can use the managed reference

<!-- ![Auto-Tracking Flow](../assets/prompt-auto-tracking-flow.png) -->

### ID Generation Rules

```
Label present → sanitized-label
No label → prompt-{content-hash}
```

Example:

```yaml
# Before auto-tracking
prompts:
  - "You are a helpful assistant"
  - label: customer-support
    raw: "You are a support agent"

# After auto-tracking
prompts:
  - pf://prompt-a5f3c2d1
  - pf://customer-support
```

## Metadata and Tags

Enhance organization with metadata:

### Tags

Categorize prompts for easy filtering:

```yaml
tags:
  - customer-facing
  - support
  - v2-migration
```

### Custom Metadata

Store additional information:

```yaml
metadata:
  team: 'Customer Success'
  compliance: 'GDPR-compliant'
  performance: 'optimized'
```

<!-- ![Metadata Usage](../assets/prompt-metadata-example.png) -->

## Access Control

Control who can perform which operations:

### Permission Levels

1. **Read**: View prompts and versions
2. **Write**: Create and update prompts
3. **Deploy**: Deploy versions to environments
4. **Admin**: Delete prompts, manage permissions

### Role-Based Access

```yaml
roles:
  developer:
    - read
    - write
  lead:
    - read
    - write
    - deploy
  admin:
    - all
```

## Integration Points

Managed prompts integrate with:

### 1. Evaluation System

```yaml
# promptfooconfig.yaml
prompts:
  - pf://assistant:production
  - pf://assistant:experimental
```

### 2. CI/CD Pipelines

```bash
# .github/workflows/deploy.yml
- name: Deploy prompt
  run: promptfoo prompt deploy assistant production --version ${{ github.sha }}
```

### 3. Monitoring Systems

```javascript
// Track prompt performance
analytics.track('prompt.usage', {
  promptId: 'assistant',
  version: 3,
  environment: 'production',
  latency: 250,
});
```

## Best Practices

### Naming Conventions

Use descriptive, hierarchical names:

```
✅ customer-support-refund
✅ api-error-handler
✅ onboarding-welcome

❌ prompt1
❌ test
❌ new-prompt
```

### Version Notes

Always include meaningful version notes:

```
✅ "Added rate limiting instructions"
✅ "Fixed grammar in error messages"
✅ "Optimized for GPT-4 Turbo"

❌ "Updated"
❌ "Changes"
❌ "v2"
```

### Environment Strategy

Follow a clear progression:

```
development → staging → production
```

## Next Steps

Now that you understand the core concepts:

- [Configuration Guide](configuration) - Detailed configuration options
- [API Reference](api-reference) - Programmatic access
- [Best Practices](best-practices) - Production patterns
- [Examples](examples/) - Real-world implementations
